<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html" charset="utf-8">
	<title>
		Weekend game
	</title>
	<link rel="stylesheet" type="text/css" href=styles.css>
</head>

<body>
	<table width="80%" align=center border=0 cellpadding=0 cellspacing=0>
		<tr>
			<td align=center class="title1">Интерпретатор
			</td>
		</tr>
		<tr>
			<td align=center class="menu">
				<br>
			</td>
		</tr>

		<tr>
			<td align=center class="menu">
				<a href="index.htm">Главная страница</a>
				|
				<a href="bankviewer_ru.htm">Просмотр банковских выписок</a>
				|
				<a href="weekendtexteditor_ru.htm">Текстовый редактор</a>
				|
				Интерпретатор
				|
				<a href="diary_ru.htm">Дневник</a>
			</td>
		</tr>

		<tr>
			<td align=center class="menu">
				<br>
				<hr size=1 noshade>
			</td>
		</tr>
	</table>

	<!-- Info -->

	<table width="80%" align=center border=0 cellpadding=0 cellspacing=0>
		<tr>
			<td class="text">
				<p><b>Интерпретатор простого языка программирования</b>. Сделан на основе ранее созданного <a
						href="https://gitflic.ru/project/weekend-game/weekendtexteditor">текстового редактора</a>, как
					расширение текстового редактора возможностью запустить на выполнение редактируемый файл, если,
					конечно, файл содержит программу. Интерпретатор является довольно самостоятельным (пакет
					game.weekend.interpreter).
					Редактор предоставляет ему только имя текущего файла и панель для отображения сообщений
					и текста, выводимого командой языка PRINT.
				</p>
				<p>
					Язык назван <b>Weekend Game Language</b>. Для расширения файлов по умолчанию выбрано <b>WGL</b>.
					Описание языка находится в <a
						href="https://gitflic.ru/project/weekend-game/weekendinterpreter">репозитории проекта</a>. Тут
					же кратко опишу работу интерпретатора. Будет удобно скачать проект, открыть его в Eclipse и по ходу
					чтения смотреть, как конкретно реализовано описываемое.
				</p>
				<p>
					Запуск интерпретатора осуществляется методом Runner.run(). Этот метод открывает текущий файл
					редактора и в отдельном потоке создаёт объект класса Interpreter, запуская его работу вызовом метода
					execute().
				</p>
				<p>
					В конструкторе Interpreter создаются необходимые для работы объекты, существующие в течение всего
					времени работы интерпретатора.
				</p>
				<p>
					Объект класса Text - это оболочка для интерпретируемого файла. Он предоставляет методы для удобного
					чтения текста программы, но это слишком низкий уровень для интерпретации. Объект класса Text
					используется читателем лексем TokenReader. TokenReader, используя Text, читает программу и
					возвращает очередную лексему. Лексема - это объект класса Token, который может быть (поле type):
					разделителем (DELIMITER), строкой (STRING), числом (NUMBER), переменной (VARIABLE), командой
					(COMMAND). Поскольку никаких изменений этот объект не производит со своими данными, я решил обойтись
					и без методов get. Переменные класса объявлены финальными, и изменить их нельзя.
					В методе execute() происходит последовательное чтение лексем. Если лексема - команда, то вызывается
					метод, отвечающий за реализацию команды. Все они находятся в классе Command. Если лексема -
					переменная, то считаю, что это оператор присваивания.
				</p>
				<p>
					<b>Переменная</b>
				</p>
				<p>
					Как говорилось в описании языка, он поддерживает использование только 26 переменных, и переменная -
					это буква латинского алфавита. За работу с переменными отвечает класс Variables. Класс содержит
					массив из 26 элементов, где хранит значения переменных, и два метода для получения значения и
					присвоения значения указанной переменной. Вот такой простой класс. </p>
				<p>
					<b>Присваивание</b>
				</p>
				<p>
					Итак, если лексема - переменная, то читаем следующую лексему и ожидаем, что это разделитель
					(DELIMITER), а именно символ =. Если это не так, то ошибка. Если так, то читаем следующее за ним
					выражение методом Expressions.getExp(). Вообще, всякий раз, когда мы ожидаем, что далее идёт
					выражение, мы будем вызывать метод Expressions.getExp(). </p>
				<p>
					Этот метод немного сложен для понимания, если вы не знакомы с термином «метод рекурсивного спуска».
					Но, говоря по-простому, мы читаем очередную лексему, запоминаем её в переменной класса token, читаем
					число методом level2(), возвращаем лексему в читатель лексем для последующего чтения и возвращаем
					прочитанное число в вызывающую программу. </p>
				<p>
					Ничего не понятно? Полный бред? Ну, я предупреждал. </p>
				<p>
					level2() отвечает за операции + и -. Это самые низкоприоритетные операции. В этом методе читаем
					число посредством level7(). Вообще-то, читаем посредством level3(), но пропустим уровни 3, 4, 5 и 6
					для облегчения понимания. Level7() вернет значение из лексемы, сохраненной в переменной класса
					token. Это обязательно должно быть число или переменная. И тут же заменит содержимое token на новую
					лексему. </p>
				<p>
					Далее смотрим в переменной класса token: это не + ли или - ли? Если так, то читаем новую лексему и
					запоминаем её на месте ранее прочитанной. Читаем второе число методом level7() и выполняем + или - с
					полученными числами и возвращаем результат. Если это не был + или -, то просто вернем значение,
					которое было получено на более низком уровне. </p>
				<p>
					level3(), 4, 5 и 6 - это методы, аналогичные level2(), но предназначенные для операций *, /, %, ^,
					унарных + и -, скобок. То есть это реализация приоритета вычисления операций. Высший уровень - это
					число или переменная, далее круглые скобки, унарные + или -, ^, *, /, % и,
					наконец, + и -. </p>
				<p>
					Теперь опишу реализацию команд.</p>
				<p>
					<b>Команда REM</b>
				</p>
				<p>
					Даю команду TokenReader-у перевести строку в читаемом файле вызовом TokenReader.nextLine(). Другими
					словами, пропускаю всё, что написано до конца строки. </p>
				<p>
					<b>Команда PRINT</b>
				</p>
				<p>
					В цикле читаю лексемы. Если это перевод строки или конец файла, то цикл заканчивается. Если это
					строка, то вывожу эту строку, иначе пытаюсь прочитать и вычислить выражение. Результат вывожу. Если
					следующая лексема - это ';' или ',', то продолжаю цикл, а иначе заканчиваю работу. </p>
				<p>
					<b>Команда PRINTLN</b>
				</p>
				<p>
					Это та же самая команда PRINT, но в конце вывожу перевод строки.</p>
				<p>
					<b>Команда INPUT</b>
				</p>
				<p>
					Читаю следующую лексему. Если это строка, то запоминаю её и читаю следующую лексему. Тут я ожидаю,
					что прочитана переменная, куда будет помещен результат ввода пользователя. Собственно, для ввода я
					использую JOptionPane.showInputDialog(). Понимаю, что это не очень хорошо, и было бы лучше сделать
					ввод в панели вывода, но этот интерпретатор - только упражнение в написании интерпретаторов, и я
					решил не усложнять программу. </p>
				<p>
					<b>Команда GOTO</b>
				</p>
				<p>
					Читаю выражение. Подразумеваю, что за GOTO следует метка строки (число), куда следует передать
					управление. Методом Labels.goToLabel(метка) передаю управление на указанную метку. Тут следует
					отвлечься на реализацию меток. </p>
				<p>
					<b>Метки</b>
				</p>
				<p>
					За работу с метками отвечает объект класса Labels. При создании объекта Labels он сканирует текст
					программы и читает число в начале каждой строки. Если такое обнаруживается, то в ArrayList
					помещается номер метки и номер строки, где она встретилась. Понятно, что имея такой список, легко по
					номеру метки получить номер строки в тексте программы, ей соответствующей. И затем, используя
					TokenReader.setLine(номер_строки), установить текущую позицию для дальнейшего чтения лексем.</p>
				<p>
					<b>Команда IF</b>
				</p>
				<p>
					Читаю выражение - левое выражение. Затем читаю лексему и надеюсь получить "&lt;", "&gt;" , "=" или
					"#". Затем читаю правое выражение. Делаю соответствующее сравнение левого и правого выражения, и
					если результат ИСТИНА, то читаю следующую лексему. Она должна быть THEN. Это должно быть THEN. Если
					результат ЛОЖЬ, я перехожу на следующую строку для считывания лексем, то есть продолжаю
					интерпретацию со строки, следующей за IF. Таким образом, команда, следующая за THEN, не будет
					выполнена.
				<p>
					<b>Команда FOR</b>
				</p>
				<p>Читаю лексему и проверяю, переменная ли
					это. Это будет переменная цикла. Затем должна следовать лексема '=' . Затем выражение - это
					начальное значение переменной цикла. Затем обязательна лексема 'TO' . Затем опять читаю
					выражение - это финальное значение переменной цикла. Если что-то из этого пошло не так, то это
					считается ошибкой. Создаю объект ForItem, который состоит из трех полей: имя переменной цикла,
					её конечное значение, номер строки начала тела цикла (номер строки, следующей сразу за командой
					FOR), и помещаю его в стек. На этом всё. Стек тут нужен для обработки вложенных циклов. Я
					ожидаю, что после команды FOR последуют какие-то команды - тело цикла, которые и начнут
					интерпретироваться сейчас, и затем обязательно последует команда NEXT - завершение цикла.
				<p>
					<b>Команда NEXT</b>
				</p>
				<p>Извлекаю из стека объект ForItem. Увеличиваю переменную цикла на единицу (да, в
					данной реализации переменная цикла всегда только увеличивается и всегда только на единицу). Если
					её значение всё ещё меньше или равно финальному значению, то опять помещаю в стек объект ForItem
					и ставлю текущей строкой строку начала тела цикла. Если нет, то ничего не делаю. И таким
					образом, далее будут обрабатываться лексемы, следующие за NEXT. Иначе говоря, я завершаю
					повторение тела цикла. </p>
				<p><b>Команда GOSUB</b></p>
				<p>После лексемы GOSUB читаю выражение. Да, в данной
					реализации подпрограммы идентифицируются не именами, а номерами. Затем запоминаю номер
					строки, следующей командой GOSUB, и помещаю её в стеке подпрограмм (самый обычный стек). Перехожу
					на строку, отмеченную указанной меткой (номером подпрограммы). Я ожидаю, что подпрограмма
					будет закончена командой RETURN.</p>
				<p><b>Команда RETURN</b></p>
				<p>Читаю из стека ранее помещенный туда номер строки, следующей за
					командой GOSUB, и ставлю её текущей для дальнейшего чтения TokenReader. Иначе говоря, я
					завершаю выполнение подпрограммы и передаю управление для дальнейшего выполнения программы.
				</p>
				<p><b>Команда END</b></p>
				<p>
					Метода, соответствующего этой лексеме, в классе Commands нет. Если встречается эта лексема,
					то интерпретатор просто завершает работу. </p>
				<p>На этом всё. Ну а более подробную информацию можно
					получить только разбирая <a href="https://gitflic.ru/project/weekend-game/weekendinterpreter">текст
						программы</a>.</p>
			</td>
		</tr>
	</table>

	<!-- End of info -->
	<table width="80%" align=center border=0 cellpadding=0 cellspacing=0>
		<tr>
			<td align=center class="menu">
				<hr size=1 noshade>
				<br>
			</td>
		</tr>

		<tr>
			<td align=center class="menu">
				<a href="index.htm">Главная страница</a>
				|
				<a href="bankviewer_ru.htm">Просмотр банковских выписок</a>
				|
				<a href="weekendtexteditor_ru.htm">Текстовый редактор</a>
				|
				Интерпретатор
				|
				<a href="diary_ru.htm">Дневник</a>
			</td>
		</tr>

		<tr>
			<td align=center class="menu">
				<br>
Смотрите мои проекты на <a href="https://github.com/weekend-game">https://github.com/weekend-game</a>
(EN) или <a href="https://gitflic.ru/user/weekend-game">https://gitflic.ru/user/weekend-game</a> (RU).<br>
Пишите мне по адресу <a href="mailto:weekend_game@mail.ru">weekend_game@mail.ru</a><br>
			</td>
		</tr>
	</table>
	<br>

</body>

</html>
